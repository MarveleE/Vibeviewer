# Fastlane configuration for Vibeviewer

default_platform(:mac)

platform :mac do
  # è·å–é¡¹ç›®æ ¹ç›®å½•ï¼ˆFastfile æ‰€åœ¨ç›®å½•çš„ä¸Šçº§ç›®å½•ï¼‰
  def project_root
    @project_root ||= File.expand_path("..", File.dirname(__FILE__))
  end
  
  # ä» Project.swift è¯»å–ç‰ˆæœ¬å·
  def get_version_from_project
    project_file = File.join(project_root, "Project.swift")
    if File.exist?(project_file)
      content = File.read(project_file)
      if match = content.match(/let appVersion\s*=\s*"([0-9]+\.[0-9]+\.[0-9]+)"/)
        return match[1]
      end
    end
    UI.user_error!("Could not find version in Project.swift at #{project_file}")
  end

  # è·å– GitHub ä»“åº“ä¿¡æ¯
  def get_github_repo
    ENV["GITHUB_REPO"] || "MarveleE/Vibeviewer"
  end

  # å…¬å…±æ–¹æ³•ï¼šæ„å»ºåº”ç”¨
  def build_app(configuration:, export_method:)
    UI.header("Building #{configuration} version")
    
    gym(
      workspace: "Vibeviewer.xcworkspace",
      scheme: "Vibeviewer",
      configuration: configuration,
      export_method: export_method,
      output_directory: "./build",
      skip_codesigning: true,
      skip_package_ipa: true,
      skip_package_pkg: true
    )
  end

  # å…¬å…±æ–¹æ³•ï¼šæŸ¥æ‰¾æ„å»ºçš„ app
  def find_built_app
    app_path = nil
    build_dir = File.join(project_root, "build")
    
    UI.message("Searching for built app...")
    UI.message("Build directory: #{build_dir}")
    
    # 1. é¦–å…ˆæ£€æŸ¥ build ç›®å½•æ ¹ç›®å½•ï¼ˆæœ€å¸¸è§çš„ä½ç½®ï¼‰
    direct_path = File.join(build_dir, "Vibeviewer.app")
    if File.exist?(direct_path)
      app_path = direct_path
      UI.message("âœ… Found app at: #{app_path}")
    # 2. é€’å½’æœç´¢ build ç›®å½•çš„æ‰€æœ‰å­ç›®å½•
    else
      UI.message("Searching in subdirectories...")
      found_paths = Dir.glob(File.join(build_dir, "**/Vibeviewer.app"))
      if found_paths.any?
        app_path = found_paths.first
        UI.message("âœ… Found app at: #{app_path}")
      end
    end
    
    # 3. å¦‚æœè¿˜æ²¡æ‰¾åˆ°ï¼Œä» archive ä¸­æå–
    unless app_path && File.exist?(app_path)
      UI.message("Checking archive...")
      archive_path = lane_context[:XCODEBUILD_ARCHIVE_PATH]
      UI.message("Archive path from context: #{archive_path.inspect}")
      
      if archive_path
        archive_path_str = archive_path.to_s
        if File.exist?(archive_path_str)
          archive_app_path = File.join(archive_path_str, "Products/Applications/Vibeviewer.app")
          if File.exist?(archive_app_path)
            app_path = archive_app_path
            UI.message("âœ… Found app in archive: #{app_path}")
          else
            UI.message("âš ï¸ Archive exists but app not found at: #{archive_app_path}")
          end
        else
          UI.message("âš ï¸ Archive path does not exist: #{archive_path_str}")
        end
      end
    end
    
    # 4. æœ€åçš„å°è¯•ï¼šåœ¨æ•´ä¸ª build ç›®å½•ä¸­æœç´¢
    unless app_path && File.exist?(app_path)
      UI.message("Performing final search in build directory...")
      all_apps = Dir.glob(File.join(build_dir, "**/*.app"))
      UI.message("Found .app bundles: #{all_apps.inspect}")
      
      vibeviewer_app = all_apps.find { |path| File.basename(path) == "Vibeviewer.app" }
      if vibeviewer_app && File.exist?(vibeviewer_app)
        app_path = vibeviewer_app
        UI.message("âœ… Found app in final search: #{app_path}")
      end
    end
    
    unless app_path && File.exist?(app_path)
      UI.user_error!("Could not find built app. Searched in:\n" +
                     "  - #{build_dir}/Vibeviewer.app\n" +
                     "  - #{build_dir}/**/Vibeviewer.app\n" +
                     "  - Archive: #{lane_context[:XCODEBUILD_ARCHIVE_PATH]}\n" +
                     "  - All .app bundles in build directory")
    end
    
    UI.success("âœ… Using app at: #{app_path}")
    return app_path
  end

  # å…¬å…±æ–¹æ³•ï¼šåˆ›å»º DMG åŒ…
  def create_dmg_package(app_path:, dmg_name:, output_directory: nil)
    UI.header("Creating DMG")
    
    # å¦‚æœæ²¡æœ‰æŒ‡å®šè¾“å‡ºç›®å½•ï¼Œä½¿ç”¨é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ build ç›®å½•
    output_dir = output_directory || File.join(project_root, "build")
    
    background_image_path = File.join(project_root, "dmg_background.png")
    background_image = File.exist?(background_image_path) ? background_image_path : nil
    
    create_dmg(
      app_path: app_path,
      dmg_name: dmg_name,
      output_directory: output_dir,
      background_image: background_image
    )
    
    dmg_path = lane_context[SharedValues::DMG_PATH]
    UI.success("DMG created: #{dmg_path}")
    return dmg_path
  end

  # Debug Lane: æ„å»º Debug ç‰ˆæœ¬å¹¶åˆ›å»º DMG
  lane :build_debug do
    # æ„å»ºåº”ç”¨
    build_app(configuration: "Debug", export_method: "development")
    
    # æŸ¥æ‰¾æ„å»ºçš„ app
    app_path = find_built_app
    
    # åˆ›å»º DMG
    version = get_version_from_project
    dmg_name = "Vibeviewer-#{version}-Debug.dmg"
    dmg_path = create_dmg_package(app_path: app_path, dmg_name: dmg_name)
    
    UI.success("Debug build completed: #{dmg_name}")
  end

  # Release Lane: å®Œæ•´å‘å¸ƒæµç¨‹
  lane :release do
    UI.header("Starting Release Process")
    
    # è·å–ç‰ˆæœ¬å·
    version = get_version_from_project
    tag_name = "v#{version}"
    github_repo = get_github_repo
    
    UI.message("Version: #{version}")
    UI.message("Tag: #{tag_name}")
    
    # æ„å»ºåº”ç”¨
    build_app(configuration: "Release", export_method: "app-store")
    
    # æŸ¥æ‰¾æ„å»ºçš„ app
    app_path = find_built_app
    
    # åˆ›å»º DMG
    dmg_name = "Vibeviewer-#{version}.dmg"
    dmg_path = create_dmg_package(app_path: app_path, dmg_name: dmg_name)
    
    # æ£€æŸ¥ Git çŠ¶æ€
    UI.header("Checking Git status")
    ensure_git_status_clean
    
    # åˆ›å»º Git tagï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    UI.header("Creating Git tag")
    begin
      sh("git", "rev-parse", "#{tag_name}", ">/dev/null", "2>&1")
      UI.important("Tag #{tag_name} already exists")
      if UI.confirm("Do you want to delete and recreate it?")
        sh("git", "tag", "-d", tag_name)
        sh("git", "push", "origin", ":refs/tags/#{tag_name}", error_callback: proc { |result| })
        add_git_tag(tag: tag_name, message: "Release version #{version}")
      end
    rescue
      add_git_tag(tag: tag_name, message: "Release version #{version}")
    end
    
    # æ¨é€ tag
    push_git_tags
    
    # ç”Ÿæˆ appcast.xml
    UI.header("Generating appcast.xml")
    dmg_url = "https://github.com/#{github_repo}/releases/download/#{tag_name}/#{dmg_name}"
    release_notes_url = "https://github.com/#{github_repo}/releases/tag/#{tag_name}"
    
    sh("bash", "Scripts/generate_appcast.sh", version, dmg_url, release_notes_url, "appcast.xml")
    
    unless File.exist?("appcast.xml")
      UI.user_error!("Failed to generate appcast.xml")
    end
    
    # åˆ›å»ºæˆ–æ›´æ–° GitHub Release
    UI.header("Creating GitHub Release")
    github_token = ENV["GITHUB_TOKEN"]
    unless github_token
      UI.user_error!("GITHUB_TOKEN environment variable is required")
    end
    
    # è·å–å˜æ›´æ—¥å¿—
    prev_tag = ""
    begin
      prev_tag = sh("git", "describe", "--tags", "--abbrev=0", "HEAD~1").strip
    rescue
      prev_tag = ""
    end
    
    changelog = ""
    if prev_tag && !prev_tag.empty?
      begin
        changelog = sh("git", "log", "#{prev_tag}..HEAD", "--pretty=format:- %s").strip
      rescue
        changelog = ""
      end
    else
      begin
        changelog = sh("git", "log", "--oneline", "-10", "--pretty=format:- %s").strip
      rescue
        changelog = ""
      end
    end
    
    release_notes = <<~NOTES
      ## æ›´æ–°å†…å®¹
      
      #{changelog}
      
      ## æŠ€æœ¯æ”¹è¿›
      
      - ç‰ˆæœ¬æ›´æ–°è‡³ #{version}
      - ä¼˜åŒ–è‡ªåŠ¨æ›´æ–°æœºåˆ¶
    NOTES
    
    # æ£€æŸ¥ Release æ˜¯å¦å·²å­˜åœ¨
    release_exists = false
    begin
      response = github_api(
        server_url: "https://api.github.com",
        api_token: github_token,
        http_method: "GET",
        path: "/repos/#{github_repo}/releases/tags/#{tag_name}"
      )
      release_exists = true
      UI.important("Release #{tag_name} already exists")
      if UI.confirm("Do you want to delete and recreate it?")
        # è·å– release ID
        release_id = response[:id] || response["id"]
        if release_id
          # åˆ é™¤ç°æœ‰ Release
          github_api(
            server_url: "https://api.github.com",
            api_token: github_token,
            http_method: "DELETE",
            path: "/repos/#{github_repo}/releases/#{release_id}"
          )
        end
        # åˆ›å»ºæ–° Release
        create_github_release(
          api_token: github_token,
          repository_name: github_repo,
          name: "Version #{version}",
          tag_name: tag_name,
          description: release_notes,
          commitish: "main"
        )
      else
        # åªä¸Šä¼ æ–‡ä»¶
        UI.message("Uploading files to existing release")
      end
    rescue => e
      # Release ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°çš„
      create_github_release(
        api_token: github_token,
        repository_name: github_repo,
        name: "Version #{version}",
        tag_name: tag_name,
        description: release_notes,
        commitish: "main"
      )
    end
    
    # ä¸Šä¼  DMG æ–‡ä»¶
    UI.header("Uploading DMG to GitHub Release")
    upload_to_github_release(
      api_token: github_token,
      repository_name: github_repo,
      tag_name: tag_name,
      file_path: dmg_path,
      asset_name: dmg_name,
      asset_content_type: "application/octet-stream"
    )
    
    # ä¸Šä¼  appcast.xml
    UI.header("Uploading appcast.xml to GitHub Release")
    upload_to_github_release(
      api_token: github_token,
      repository_name: github_repo,
      tag_name: tag_name,
      file_path: "appcast.xml",
      asset_name: "appcast.xml",
      asset_content_type: "application/xml"
    )
    
    UI.success("ğŸ‰ Release completed successfully!")
    UI.message("Release URL: https://github.com/#{github_repo}/releases/tag/#{tag_name}")
  end
end

